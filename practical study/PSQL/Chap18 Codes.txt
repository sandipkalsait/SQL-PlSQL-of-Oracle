Example 1:
	CREATE OR REPLACE FUNCTION F_CHKACCTNO(vACCT_NO IN VARCHAR2) 
		RETURN NUMBER IS
/* Variable that hold data from the TRANS_MSTR table */
		dummyAcctNo VARCHAR2(10);

	BEGIN
		SELECT DISTINCT ACCT_NO INTO dummyAcctNo FROM TRANS_MSTR 
			WHERE ACCT_NO = vACCT_NO;

/* If the SELECT statement retrieves data, return value is set to 1. */ 
		RETURN 1;

	EXCEPTION
/* If the SELECT statement does not retrieve data, return value is set to 0 */
		WHEN NO_DATA_FOUND THEN
			RETURN 0;
	END;

DECLARE 
/* Cursor SCANTABLE retrieves the required data from the table ACCT_MSTR */
	CURSOR SCANTABLE IS 
		SELECT ACCT_NO, TYPE FROM ACCT_MSTR;

 
/* Variables that hold data from the cursor scantable */
	mACCT_NO ACCT_MSTR.ACCT_NO%type;
	mTYPE ACCT_MSTR.TYPE%type;

/* Variable that stores the value returned by the f_ChkAccctNo function i.e. 1 or 0 */
	valexists NUMBER(1);

BEGIN
	OPEN SCANTABLE;
	LOOP
	  	FETCH SCANTABLE INTO MACCT_NO, MTYPE;
		EXIT WHEN SCANTABLE%NOTFOUND;

	/* Call function F_CHKACCTNO to check if ACCT_NO is present in TRANS_MSTR table */
		valexists := F_CHKACCTNO(MACCT_NO);

	/* If ACCT_NO does not exist insert a record in the TRANS_MSTR table */
		IF valexists = 0 THEN
			IF mTYPE = 'SB' THEN
				INSERT INTO TRANS_MSTR (TRANS_NO, ACCT_NO, DT, TYPE, PARTICULAR, DR_CR, AMT, BALANCE) 
					VALUES((SELECT 'T' || TO_CHAR(MAX(TO_NUMBER(SUBSTR( TRANS_NO, 2))) + 1) FROM TRANS_MSTR), mACCT_NO, SYSDATE, 'C', 'Initial Payment', 'D', 500, 500);
			ELSE
				INSERT INTO TRANS_MSTR (TRANS_NO, ACCT_NO, DT, TYPE, PARTICULAR, DR_CR, AMT, BALANCE) 
					VALUES((SELECT 'T' || TO_CHAR(MAX(TO_NUMBER(SUBSTR( TRANS_NO, 2))) + 1) FROM TRANS_MSTR), mACCT_NO, SYSDATE, 'C', 'Initial Payment', 'D', 2000, 2000);
			END IF;
		END IF;
	END LOOP;
	CLOSE SCANTABLE;
	COMMIT;
END;


Example 2:
CREATE OR REPLACE PROCEDURE PROC_INSUPD(VFD_NO IN VARCHAR2, VACCT_NO IN VARCHAR2, vAMT IN NUMBER) IS
/* Variable declarations */
	mCurBal number;

BEGIN
/* Retrieving the current balance */
	SELECT CURBAL INTO mCurBal FROM ACCT_MSTR WHERE ACCT_NO = vACCT_NO;

/* Inserting a record in the TRANS_MSTR table */
	INSERT INTO TRANS_MSTR (TRANS_NO, ACCT_NO, DT, TYPE, PARTICULAR, DR_CR, AMT, BALANCE) 
		VALUES((SELECT 'T' || TO_CHAR(MAX(TO_NUMBER(SUBSTR(TRANS_NO, 2))) + 1) FROM TRANS_MSTR), vACCT_NO, SYSDATE, 'C', 'Fixed Deposit Payment', 'D', vAMT, (mCurBal + vAMT));

/* Updating the CURBAL in the ACCT_MSTR table */
	UPDATE ACCT_MSTR SET CURBAL = CURBAL + vAMT WHERE ACCT_NO = vACCT_NO;

/* Updating the STATUS in the FD_DTLS table */
	UPDATE FD_DTLS SET STATUS = 'M' WHERE FD_NO = vFD_NO;
END;


DECLARE 
/* Cursor CRSR_FDCHK retrieves all the records of table FD_DTLS which are active and due for payment */
	CURSOR CRSR_FDCHK IS 
		SELECT FD_NO, PAYTO_ACCTNO, DUEAMT FROM FD_DTLS 
			WHERE TO_CHAR(DUEDT,'DD-MM-YY') = TO_CHAR(SYSDATE,'DD-MM-YY') 
				AND STATUS = 'A' AND PAYTO_ACCTNO IS NOT NULL;

/* Declaration of memory variables that will hold values */
	mFD_NO VARCHAR2(10);
	mPAYTO_ACCTNO VARCHAR2(10);
	mAMT NUMBER(8,2);
	mState NUMBER := 0;

 
BEGIN
/* Opening the cursor */
	OPEN CRSR_FDCHK;
	LOOP
		FETCH CRSR_FDCHK INTO mFD_NO, mPAYTO_ACCTNO, mAMT;
		EXIT WHEN CRSR_FDCHK%NOTFOUND;
		/* Call procedure proc_insupd to perform insert/update operations on tables. */
			proc_insupd(mFD_NO, mPAYTO_ACCTNO, mAMT);
		/* Updating the state to 1 i.e. there are fds due for payment */
			mState := 1;
	END LOOP;

/* Display a message if no FDs are due for payment based on the mState variable */
	IF mState = 0 THEN
		DBMS_OUTPUT.PUT_LINE('Currently there are no fixed deposits due for payment.');
	END IF;
CLOSE CRSR_FDCHK;
	COMMIT;
END;


Example 3:
DROP PROCEDURE PROC_INSUPD;

Example 4:
DROP FUNCTION F_CHKACCTNO;


Example 5:
CREATE PACKAGE BNK_PCK_SPEC IS 
	FUNCTION F_CHKACCTNO(VACCT_NO IN VARCHAR2) RETURN NUMBER;
	PROCEDURE PROC_INSUPD(VFD_NO IN VARCHAR2, VACCT_NO IN VARCHAR2, VAMT IN NUMBER);
	END BNK_PCK_SPEC;


Example 6:
CREATE PACKAGE COSTINGS IS
	TYPE REC IS RECORD(PART_NAME VARCHAR2(30),  PART_PRICE NUMBER, PART_COST NUMBER);
	PRICE NUMBER;
	QTY NUMBER;
	NO_COST EXCEPTION;
	COST_OR EXCEPTION;
END COSTINGS;


Example 7:
CREATE OR REPLACE PACKAGE TRANSACTION_MGMT AS 
	PROCEDURE PERFORM_TRANS(mACCT_NO VARCHAR2, MD VARCHAR2, AMT NUMBER);
	PROCEDURE CANCEL_FD(mFD_NO VARCHAR2);
	BAL NUMBER;
	P_ACCT_NO VARCHAR2(10);
	D_AMT NUMBER;
END TRANSACTION_MGMT;


Example 8:
CREATE OR REPLACE PACKAGE BODY TRANSACTION_MGMT AS
	PROCEDURE PERFORM_TRANS(mACCT_NO VARCHAR2, MD VARCHAR2, AMT NUMBER) IS
	BEGIN
		SELECT CURBAL INTO BAL FROM ACCT_MSTR WHERE ACCT_NO = mACCT_NO;

		IF MD = 'D' THEN 
			INSERT INTO TRANS_MSTR(TRANS_NO, ACCT_NO, DT, TYPE, PARTICULAR, DR_CR, AMT, BALANCE) 
				VALUES((SELECT 'T' || TO_CHAR(MAX(TO_NUMBER(SUBSTR( TRANS_NO, 2))) + 1) FROM TRANS_MSTR), mACCT_NO, SYSDATE, 'C', 'Deposit', MD, AMT, (BAL + AMT));
			UPDATE ACCT_MSTR SET CURBAL = CURBAL + AMT 
				WHERE ACCT_NO = mACCT_NO;
		ELSE
			IF AMT < BAL THEN
				INSERT INTO TRANS_MSTR(TRANS_NO, ACCT_NO, DT, TYPE, PARTICULAR, DR_CR, AMT, BALANCE) 
					VALUES((SELECT 'T' || TO_CHAR(MAX(TO_NUMBER(SUBSTR( TRANS_NO, 2))) + 1) FROM TRANS_MSTR), mACCT_NO, SYSDATE, 'C', 'Withdrawal', MD, AMT, (BAL - AMT));
				UPDATE ACCT_MSTR SET CURBAL = CURBAL - AMT 
					WHERE ACCT_NO = mACCT_NO;
			END IF;
		END IF;
	END;


Example 9:
DECLARE 
	balance number;
BEGIN
	. . .
	IF TRANSACTION_MGMT.BAL < balance THEN
		. . . 
	END IF;

The first procedure defined in the above package can be executed as follows:
EXECUTE TRANSACTION_MGMT.PERFORM_TRANS('SB1', 'D', 5000);


Example 10:
ALTER PACKAGE TRANSACTION_MGMT COMPILE BODY;

Example 11:
CREATE OR REPLACE PACKAGE PCK_DEL IS
	PROCEDURE DEL_EMP_BRANCH(mBRANCH_NO VARCHAR2);
	FUNCTION CNT_EMP_BRANCH(mBRANCH_NO VARCHAR2) RETURN NUMBER; 
END PCK_DEL;

CREATE OR REPLACE PACKAGE BODY PCK_DEL IS
	PROCEDURE DEL_EMP_BRANCH(mBRANCH_NO VARCHAR2) IS noemp NUMBER;
	BEGIN
		noemp := CNT_EMP_BRANCH(mBRANCH_NO);
		IF noemp < 2 AND noemp > 0 THEN
			DELETE EMP_MSTR WHERE BRANCH_NO = mBRANCH_NO;
			DBMS_OUTPUT.PUT_LINE('All the employees belonging to the branch ' || mBRANCH_NO || ' deleted sucessfully');
			DELETE BRANCH_MSTR WHERE BRANCH_NO = mBRANCH_NO;
			DBMS_OUTPUT.PUT_LINE('Branch ' || mBRANCH_NO || ' deleted sucessfully');
		END IF;

		IF noemp = 0 THEN
			DBMS_OUTPUT.PUT_LINE('There exist no employees in the branch.');
		END IF;

 
		IF noemp >= 2 THEN
			DBMS_OUTPUT.PUT_LINE('There exist ' || noemp || ' employees in the branch ' || mBRANCH_NO || ' Skipping Deletion.');
		END IF;
	END;

Situation 1:
EXECUTE PCK_DEL. DEL_EMP_BRANCH ('B5');

Situation 2: 
EXECUTE PCK_DEL. DEL_EMP_BRANCH ('B1');

Situation 3:
EXECUTE PCK_DEL. DEL_EMP_BRANCH ('B6');

Example 12:
CREATE OR REPLACE PACKAGE CHECK_FUNC IS
	FUNCTION VALUE_OK(DATE_IN IN DATE) RETURN VARCHAR2;
	FUNCTION VALUE_OK(NUMBER_IN IN NUMBER) RETURN VARCHAR2;
END;


CREATE OR REPLACE PACKAGE BODY CHECK_FUNC IS
	FUNCTION VALUE_OK (DATE_IN IN DATE) RETURN VARCHAR2 IS
	BEGIN
		IF DATE_IN <= SYSDATE THEN
			RETURN 'Output From the First Over loaded Function: TRUE';
		ELSE
			RETURN 'Output From the First Over loaded Function: FALSE';
		END IF;
	END;
FUNCTION VALUE_OK (NUMBER_IN IN NUMBER) RETURN VARCHAR2 IS
	BEGIN
		IF NUMBER_IN > 0 THEN
			RETURN 'Output From the Second Over loaded Function: TRUE';
		ELSE
			RETURN 'Output From the Second Over loaded Function: FALSE';
		END IF;
	END;
END;

Example 13:
	DATE_STRING := TO_CHAR(SYSDATE, 'DD/MM/YY');
	NUMBER_STRING := TO_CHAR(10000, '$099,999');

Example 15:
CREATE OR REPLACE PACKAGE BODY STRING_FNS IS 
	PROCEDURE TRIM_AND_CENTER (STRING_IN IN CHAR, STRING_OUT OUT CHAR)
	BEGIN
		. . .
	END;

	PROCEDURE TRIM_AND_CENTER (STRING_IN IN VARCHAR2, STRING_OUT OUT VARCHAR2)
	BEGIN
		. . .
	END;
END;


Example 16:
CREATE OR REPLACE PACKAGE BODY CHECK_DATE IS
	FUNCTION VALUE_OK(DATE_IN IN DATE) RETURN BOOLEAN IS
	BEGIN
		RETURN DATE_IN <= SYSDATE;
	END;

	FUNCTION VALUE_OK(DATE_OUT IN DATE)RETURN BOOLEAN IS
	BEGIN
		RETURN DATE_OUT >= SYSDATE;
	END;
END;


Example 17:
CREATE OR REPLACE PACKAGE BODY CHECK_RETURN IS
	FUNCTION VALUE_OK(DATE_IN IN DATE) RETURN BOOLEAN IS
	BEGIN
		RETURN DATE_IN <= SYSDATE ;
	END;
	FUNCTION VALUE_OK(DATE_OUT IN DATE ) RETURN NUMBER IS
	BEGIN
		IF DATE_OUT >= SYSDATE THEN
			RETURN 1;
		ELSE
			RETURN 0;
		END IF;
	END;
END;


Example 18:
PROCEDURE DEVELOP_ANALYSIS (QUARTER_END_IN IN DATE, SALES_IN IN NUMBER)  IS
	PROCEDURE REVISE_ESTIMATE (DATE_IN IN DATE) IS
	BEGIN
		PROCEDURE REVISE_ESTIMATE (DOLLAR_IN IN NUMBER) IS
		BEGIN
			. . .
		END;

	      BEGIN
			REVISE_ESTIMATE(QUARTER_END_IN);
			REVISE_ESTIMATE(DOLLARS_IN);
	      END;
	END;

Example 19:
CREATE OR REPLACE PACKAGE ACCT_MNTC IS 
	PROCEDURE ACT_ACCTS(vBRANCH_NO IN NUMBER);
	PROCEDURE ACT_ACCTS (vNAME IN VARCHAR2);
END;

CREATE OR REPLACE PACKAGE BODY ACCT_MNTC IS 
	PROCEDURE ACT_ACCTS(vBRANCH_NO IN NUMBER) IS 
	BEGIN
		UPDATE ACCT_MSTR SET STATUS = 'A'  
			WHERE BRANCH_NO = 'B' || vBRANCH_NO AND STATUS = 'S';
		IF SQL%ROWCOUNT > 0 THEN
			DBMS_OUTPUT.PUT_LINE(TO_CHAR(SQL%ROWCOUNT) || ' Account(s) Activated Successfully');
		ELSE
			DBMS_OUTPUT.PUT_LINE('Currently there exist no Inactive Accounts in the branch no ' || vBRANCH_NO);
		END IF;
	END;

	PROCEDURE ACT_ACCTS(vNAME IN VARCHAR2) IS	
	BEGIN
		UPDATE ACCT_MSTR SET STATUS = 'A' WHERE STATUS = 'S' 
			AND BRANCH_NO IN(SELECT BRANCH_NO FROM BRANCH_MSTR 
				WHERE NAME = vNAME);
		IF SQL%ROWCOUNT > 0 THEN
			DBMS_OUTPUT.PUT_LINE(TO_CHAR(SQL%ROWCOUNT) || ' Account(s) Activated Successfully');
		ELSE
			DBMS_OUTPUT.PUT_LINE('Currently there exist no Inactive Accounts in the branch ' || vNAME);
		END IF;
	END;
END ACCT_MNTC;


Example 20:
CREATE TABLE "DBA_BANKSYS"."AUDIT_CUST"(
	"CUST_NO" VARCHAR2(10), "FNAME" VARCHAR2(25), "MNAME" VARCHAR2(25), 
	"LNAME" VARCHAR2(25), "DOB_INC" DATE NOT NULL, "OCCUP" VARCHAR2(25), 
	"PHOTOGRAPH" VARCHAR2(25), "SIGNATURE"  VARCHAR2(25), "PANCOPY" VARCHAR2(1), 
	"FORM60" VARCHAR2(1), "OPERATION" VARCHAR2(20), "USERID" VARCHAR2(20),
	"ODATE" DATE);

CREATE TRIGGER AUDIT_TRAIL
	AFTER UPDATE OR DELETE ON CUST_MSTR 
		FOR EACH ROW
DECLARE
/* The value in the OPER variable will be inserted into the operation field in the AUDIT_CUST table */
	OPER VARCHAR2(8);

BEGIN
/* If the records are updated in the CUST_MSTR table then OPER is set to 'UPDATE'. */ 
	IF updating THEN 
		OPER := 'UPDATE';
	END IF;
/* If the records are deleted from the CUST_MSTR table then OPER is set to 'DELETE'. */
	IF deleting THEN
		OPER := 'DELETE';
	END IF;
/* Insert the old values in the AUDIT_CUST table. */
	INSERT INTO AUDIT_CUST VALUES (:OLD.CUST_NO, :OLD.FNAME, :OLD.MNAME, :OLD.LNAME, :OLD.DOB_INC, :OLD.OCCUP, :OLD.PHOTOGRAPH, :OLD.SIGNATURE, :OLD.PANCOPY, :OLD.FORM60, OPER, USER, SYSDATE);
END;

SELECT CUST_NO, FNAME, MNAME, LNAME, DOB_INC, OPERATION, ODATE, USER 
	FROM AUDIT_CUST;

Case 1:
UPDATE CUST_MSTR SET DOB_INC = '1-FEB-1981' WHERE FNAME = 'Hansel';

SELECT CUST_NO, FNAME, MNAME, LNAME, DOB_INC FROM CUST_MSTR;

SELECT CUST_NO, FNAME, MNAME, LNAME, DOB_INC, OPERATION, ODATE, USER 
	FROM AUDIT_CUST;

Case 2:
SELECT CUST_NO, FNAME, MNAME, LNAME, DOB_INC FROM CUST_MSTR;

SELECT CUST_NO, FNAME, MNAME, LNAME, DOB_INC, OPERATION, ODATE, USER 
	FROM AUDIT_CUST;

Example 21: 
CREATE OR REPLACE TRIGGER TRANS_CHECK
	BEFORE INSERT ON TRANS_MSTR 
		FOR EACH ROW 
DECLARE
	v_CNT_ACCT_NO VARCHAR2(10);
	v_CURBAL NUMBER(10);
	
BEGIN
/* Checking if the account number is a valid account number. */
	SELECT COUNT(ACCT_NO) INTO v_CNT_ACCT_NO 
		FROM ACCT_MSTR WHERE ACCT_NO = :new.ACCT_NO;
	IF v_CNT_ACCT_NO = 0 THEN			
		RAISE_APPLICATION_ERROR(-20000,'The Account number is invalid.');
	END IF;
/* Checking if the transaction amount is a positive number. */
	IF :new.AMT <= 0 THEN			
		RAISE_APPLICATION_ERROR(-20001,'The Transaction amount cannot be negative or zero.');
	END IF;
/* Checking if the transaction amount exceeds the current balance in case of withdrawals. */
	SELECT CURBAL INTO v_CURBAL 
		FROM ACCT_MSTR WHERE ACCT_NO = :new.ACCT_NO;
	IF v_CURBAL < :new.AMT AND :new.DR_CR = 'W' THEN
		RAISE_APPLICATION_ERROR(-20002,'The amount of withdrawal cannot exceed the balance held in the account.');
	END IF;
END;


Case 1:
INSERT INTO TRANS_MSTR (TRANS_NO, ACCT_NO, DT, TYPE, PARTICULAR, DR_CR, AMT, BALANCE) 
	VALUES('T32', 'SB3', '15-DEC-2003', 'B', 'Initial Payment', 'D', -2, 500);
INSERT INTO TRANS_MSTR (TRANS_NO, ACCT_NO, DT, TYPE, PARTICULAR, DR_CR, AMT, BALANCE)
*
ERROR at line 1:
ORA-20001: The Transaction amount cannot
be negative or zero.
ORA-06512: at "DBA_BANKSYS.TRANS_CHECK", line 16
ORA-04088: error during execution of trigger 'DBA_BANKSYS.TRANS_CHECK'


Case 2:
INSERT INTO TRANS_MSTR (TRANS_NO, ACCT_NO, DT, TYPE, PARTICULAR, DR_CR, AMT, BALANCE) 
	VALUES('T32', 'SB33', '15-DEC-2003', 'B', 'Initial Payment', 'W', -2, 500);
INSERT INTO TRANS_MSTR (TRANS_NO, ACCT_NO, DT, TYPE, PARTICULAR, DR_CR, AMT, BALANCE)
*
ERROR at line 1:
ORA-20000: The Account number is invalid.
ORA-06512: at "DBA_BANKSYS.TRANS_CHECK", line 11
ORA-04088: error during execution of trigger 'DBA_BANKSYS.TRANS_CHECK'

Case 3:
INSERT INTO TRANS_MSTR (TRANS_NO, ACCT_NO, DT, TYPE, PARTICULAR, DR_CR, AMT, BALANCE) 
	VALUES('T32', 'SB3', '15-DEC-2003', 'B', 'Initial Payment', 'W', 99999, 500);
INSERT INTO TRANS_MSTR (TRANS_NO, ACCT_NO, DT, TYPE, PARTICULAR, DR_CR, AMT, BALANCE)
*
ERROR at line 1:
ORA-20002: The amount of withdrawal cannot
exceed the balance held in the account.
ORA-06512: at "DBA_BANKSYS.TRANS_CHECK", line 25
ORA-04088: error during execution of trigger 'DBA_BANKSYS.TRANS_CHECK'

Example 22: 
CREATE SEQUENCE CUST_SEQ INCREMENT BY 1 START WITH 1;

Example 23: 
Database Trigger Creation

CREATE OR REPLACE TRIGGER CUST_NO_GENERATION
	BEFORE INSERT ON CUST_MSTR
		FOR EACH ROW
DECLARE
	PRIMARY_KEY_VALUE VARCHAR2(10);
BEGIN
	SELECT 'C' || TO_CHAR(CUST_SEQ.NEXTVAL) 
		INTO PRIMARY_KEY_VALUE FROM DUAL;
	:new.CUST_NO := PRIMARY_KEY_VALUE;
END;

Example 24: 

CREATE OR REPLACE TRIGGER EMP_NO_GENERATION
	BEFORE INSERT ON EMP_MSTR
		FOR EACH ROW
DECLARE
	MAX_PKEY_VALUE VARCHAR2(10);
	NEW_PKEY_VALUE VARCHAR2(10);
BEGIN
	SELECT NVL(MAX(TO_NUMBER(SUBSTR(EMP_NO,2))), 0) INTO MAX_PKEY_VALUE FROM EMP_MSTR;
	NEW_PKEY_VALUE := TO_CHAR((TO_NUMBER(MAX_PKEY_VALUE) + 1));
	:NEW.EMP_NO := 'E' || NEW_PKEY_VALUE;
END;


INSERT INTO EMP_MSTR (BRANCH_NO, FNAME, MNAME, LNAME, DEPT, DESIG, MNGR_NO) 
	VALUES('B1', 'Ivan', 'Nelson', 'Bayross', 'Administration', 'Managing Director', NULL);

Example 25: 
Creating Lookup Table

CREATE TABLE pkey_lookup (pkey_value VARCHAR2(10));

Output:
Table created.

Create Database Trigger

CREATE OR REPLACE TRIGGER BRANCH_NO_GENERATION
	BEFORE INSERT ON BRANCH_MSTR
		FOR EACH ROW
DECLARE
	LOOKUP_PKEY_VALUE VARCHAR2(10);
	NEW_PKEY_VALUE VARCHAR2(10);
BEGIN
	BEGIN
		SELECT PKEY_VALUE INTO LOOKUP_PKEY_VALUE FROM PKEY_LOOKUP;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			LOOKUP_PKEY_VALUE := 'B1';
	END;
	:new.BRANCH_NO := LOOKUP_PKEY_VALUE;
	NEW_PKEY_VALUE := TO_NUMBER(SUBSTR(LOOKUP_PKEY_VALUE, 2, 1)) + 1;
	LOOKUP_PKEY_VALUE := 'B' || NEW_PKEY_VALUE;
	IF LOOKUP_PKEY_VALUE = 'B2' THEN
		INSERT INTO PKEY_LOOKUP VALUES (LOOKUP_PKEY_VALUE);
	ELSE
		UPDATE PKEY_LOOKUP SET PKEY_VALUE = LOOKUP_PKEY_VALUE;
	END IF;
END;


INSERT INTO BRANCH_MSTR (NAME) VALUES('Vile Parle (HO)');

Example 27: 
Wrong Syntax - Error Encountered In Oracle Verbs

SELECT * BRANCH_MSTR;


Example 28: 
SELECT BRANCH_NO, BRANCH_NAME FROM BRANCH_MSTR;

Example 27:

CREATE PROCEDURE RAISE (vACCT_NO IN VARCHAR2, vINCBY IN NUMBER) IS
	CURSOR_HANDLE INTEGER;
	ACCT_UPDATED INTEGER;
BEGIN
	CURSOR_HANDLE := DBMS_SQL.OPEN_CURSOR;
		. . . PROCESSING . . .
END;


CREATE PROCEDURE PARSE(CURSOR_HANDLE IN INTEGER, SQL_SENTENCE IN VARCHAR2, LANGUAGE_FLAG IN INTEGER);

Example 28:
CREATE PROCEDURE RAISE (vACCT_NO IN VARCHAR2, vINCBY IN NUMBER) IS
CURSOR_HANDLE INTEGER;
ACCT_UPDATED INTEGER;
BEGIN
	CURSOR_HANDLE := DBMS_SQL.OPEN_CURSOR;
	DBMS_SQL.PARSE (CURSOR_HANDLE, 'UPDATE ACCT_MSTR SET CURBAL = CURBAL + :INCBY_AMOUNT WHERE ACCT_NO = :ACCTNO', DBMS_SQL.V7);
		. . . PROCESSING . . .
END;

PROCEDURE BIND_VARIABLE (CURSOR_HANDLE IN INTEGER, VARIABLE_NAME IN VARCHAR2, VALUE IN INTEGER);
PROCEDURE BIND_VARIABLE (CURSOR_HANDLE IN INTEGER, VARIABLE_NAME IN VARCHAR2, VALUE IN DATE);
PROCEDURE BIND_VARIABLE (CURSOR_HANDLE IN INTEGER, VARIABLE_NAME IN VARCHAR2, VALUE IN VARCHAR2);


Example 30:
CREATE PROCEDURE COLUMN_VALUE(CURSOR_HANDLE IN INTEGER, POSITION IN INTEGER, VALUE OUT DATE [, COLUMN_ERROR OUT NUMBER] [, ACTUAL_LENGTH OUT INTEGER] );
CREATE PROCEDURE COLUMN_VALUE(CURSOR_HANDLE IN INTEGER, POSITION IN INTEGER, VALUE OUT NUMBER [, COLUMN_ERROR OUT NUMBER] [, ACTUAL_LENGTH OUT INTEGER] );
CREATE PROCEDURE COLUMN_VALUE(CURSOR_HANDLE IN INTEGER, POSITION IN INTEGER, VALUE OUT VARCHAR2 [, COLUMN_ERROR OUT NUMBER] [, ACTUAL_LENGTH OUT INTEGER] );
CREATE PROCEDURE COLUMN_VALUE(CURSOR_HANDLE IN INTEGER, POSITION IN INTEGER, VALUE OUT RAW [, COLUMN_ERROR OUT NUMBER] [, ACTUAL_LENGTH OUT INTEGER] );
CREATE PROCEDURE COLUMN_VALUE(CURSOR_HANDLE IN INTEGER, POSITION IN INTEGER, VALUE OUT ROWID [, COLUMN_ERROR OUT NUMBER] [, ACTUAL_LENGTH OUT INTEGER] );


CREATE PROCEDURE DEFINE_COLUMN (CURSOR_HANDLE IN INTEGER, POSITION IN INTEGER, COLUMN IN DATE);
CREATE PROCEDURE DEFINE_COLUMN (CURSOR_HANDLE IN INTEGER, POSITION IN INTEGER, COLUMN IN NUMBER);
CREATE PROCEDURE DEFINE_COLUMN (CURSOR_HANDLE IN INTEGER, POSITION IN VARCHAR2, COLUMN IN INTEGER, COLUMN_SIZE IN INTEGER);


Example 31:

In case of a normal or static:
	FETCH ACCT_CUR INTO ACCT_REC;
	IF ACCT_CUR %NOTFOUND THEN
		. . . PROCESSING . . .
	END IF;

In case of DBMS_SQL used to fetch rows:
	IF DBMS_SQL.FETCH_ROWS (CURSOR_HANDLE) > 0  THEN
		. . . PROCESSING . . .
	END IF;

CREATE PROCEDURE VARIABLE_VALUE (CURSOR_HANDLE IN INTEGER, VARIABLE_NAME IN VARCHAR2, VALUE OUT NUMBER);
PROCEDURE VARIABLE_VALUE (CURSOR_HANDLE IN INTEGER, VARIABLE_NAME IN VARCHAR2, VALUE OUT DATE);
PROCEDURE VARIABLE_VALUE (CURSOR_HANDLE IN INTEGER, VARIABLE_NAME IN VARCHAR2, VALUE OUT VARCHAR2);


CREATE PROCEDURE CLOSE_CURSOR (cursor_handle IN OUT INTEGER);

Example 32:

BEGIN
		. . . PROCESSING . . .
	DBMS_SQL.CLOSE_CURSOR (CURSOR_HANDLE);
END;

Example 33:
CREATE OR REPLACE FUNCTION PKEY_CHK (TABLE_NAME IN VARCHAR2, COL_NAME IN VARCHAR2, COL_VALUE IN VARCHAR2) RETURN NUMBER AS
/* Declaring a handle to the Dynamic SQL cursor. */
	CURSOR_HANDLE INTEGER;
/* Variable that holds the return value from the EXECUTE. */
	EXECUTE_FEEDBACK INTEGER;	

BEGIN
/* Open new cursor and return cursor ID. */ 
	CURSOR_HANDLE := DBMS_SQL.OPEN_CURSOR;

/* Parse the query with the columns in the SELECT list. */
	DBMS_SQL.PARSE (CURSOR_HANDLE, 'SELECT ' || COL_NAME || ' FROM ' || TABLE_NAME || ' WHERE ' || COL_NAME || ' = ''' || COL_VALUE || '''', DBMS_SQL.V7);

/* Execute the SQL statement. */
	EXECUTE_FEEDBACK := DBMS_SQL.EXECUTE(CURSOR_HANDLE);

/* Returning values 0 or 1 depending upon whether the select returned a row or not and closing the cursor. */
	IF DBMS_SQL.FETCH_ROWS (CURSOR_HANDLE) = 0 THEN
		DBMS_SQL.CLOSE_CURSOR (CURSOR_HANDLE);
		RETURN 0;
	ELSE
		DBMS_SQL.CLOSE_CURSOR (CURSOR_HANDLE);
		RETURN 1;
	END IF;
END;


DECLARE
/* Declaring a variable that will hold the return value of the function. */
	ROWS_FOUND NUMBER;
BEGIN
/* Calling the function PKEY_CHK that takes the table name and column name/s as the IN parameter and returns a number. */
	ROWS_FOUND := PKEY_CHK ('&TABLENAME', '&COLUMNNAME', '&COLUMNVALUE');
/* Displaying message to the user */
	IF ROWS_FOUND = 0 THEN
		DBMS_OUTPUT.PUT_LINE ('The column value is unique');
	ELSE
		DBMS_OUTPUT.PUT_LINE ('The column value is not unique');
	END IF;
END;

Example 36:
CREATE OR REPLACE PROCEDURE DROP_OBJECT_PROC (TYPE_IN IN VARCHAR2, NAME_IN IN VARCHAR2) IS
/* The static cursor retrieving the object. */
	CURSOR OBJ_CUR IS 
		SELECT OBJECT_NAME, OBJECT_TYPE FROM USER_OBJECTS 
			WHERE OBJECT_NAME LIKE UPPER(NAME_IN) 
				AND OBJECT_TYPE LIKE UPPER(TYPE_IN) ORDER BY OBJECT_NAME;
/* Declaring a handle to the Dynamic SQL cursor. */
	CURSOR_HANDLE INTEGER;
BEGIN
/* For each matching object. */
	FOR OBJ_REC IN OBJ_CUR
	LOOP
	/* OPEN NEW CURSOR AND RETURN CURSOR ID. */ 
		CURSOR_HANDLE := DBMS_SQL.OPEN_CURSOR;
	/* CONSTRUCT THE SQL STATEMENT AND PARSE IT IN VERSION 7 MODE. */
		DBMS_SQL.PARSE (CURSOR_HANDLE, 'DROP ' || OBJ_REC.OBJECT_TYPE || ' ' || OBJ_REC.OBJECT_NAME, DBMS_SQL.V7);
	/* CLOSE THE CURSOR. */ 
		DBMS_SQL.CLOSE_CURSOR (CURSOR_HANDLE);
	END LOOP;
END;


BEGIN
/* Call to the procedure DROP_OBJECT_PROC. The two parameters the procedure takes is the type of object and the name of the object.*/
	DROP_OBJECT_PROC ('SEQUENCE', 'CUST_SEQ');
	DBMS_OUTPUT.PUT_LINE ('Object Dropped Successfully');
END;












